---
title: "Imputation with Spaceship Titanic"
author: "Alejandro Hernandez"
date: "2022-08-04"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# set working directory to project directory (outside of SRC folder)
split <- str_split(getwd(), "/", simplify = TRUE)
wdir <- paste(split[-length(split)], collapse = "/")
knitr::opts_knit$set(root.dir = wdir)
```

```{r, include=FALSE}
rm(list=ls())
library(stringr)  # string manipulation
library(dplyr)  # data frame manipulation
library(mice) # imputation functions
library(ggplot2)  # plotting
library(tidyr)  # replacing NA
```

Imputation is the practice of assigning a missing value to an observation/record by inference or prediction. The goal of this script is to impute the necessary fields of the *Spaceship Titanic* dataset. Preferred methods of imputation vary by dataset, so we aim to compare the utility between multiple methods.

First, let's import our dataset, edit some variable types, and count missing values in each field.

```{r}
# get training set
train <- read.csv(sprintf("%s/data/train.csv", getwd()), na.strings = "")

# split aggregate columns
train <- separate(train, col=Cabin, into=c("Deck", "Num", "Side"), sep='/')
train <-  separate(train, col=PassengerId , into=c("GroupId", "PersonalId"), sep='_')
train <-  separate(train, col=Name , into=c("FirstName", "LastName"), sep=' ')

# convert GroupId, PersonalId, and Num to type INTEGER
train[c(1,2,6)] <- sapply(train[c(1,2,6)], as.integer)

# convert missing first and last names to "NONE"
# imputation treats NA, and it wouldn't make sense to impute
train <- train %>%
  mutate_at(c('FirstName','LastName'), ~ replace_na(.,"NONE"))

# encode columns of type LOGICAL to INTEGER (TRUE = 1, FALSE = 0)
train <- train %>%
  mutate_if(is.logical, as.integer)

# confirm each variable is the correct type
sapply(train, typeof)
```

```{r}
# in each column...
# count number of missing values
colSums(is.na(train))
# count proportion of missing values
round(colSums(is.na(train)) / nrow(train), 3)
```

Fields that have missing values are only missing around 200 (barely 2% of their data) so we can continue with imputation without worrying that the majority of the data is being estimated by us.

Now, we can explore methods of imputation.

## Mean/Mode Imputation

Filling missing values of a variable with the variable's mean (if numeric) or mode (if categorical) is a quick, simple, and easy strategy to implement that seems- at a glance- reasonable. However, there are some serious drawbacks to this method. For numeric data, because mean imputed values are totally independent from other predictors, they have the potential to erase correlation between variables.

```{r}
# define function to compute mode
getmode <- function(v, na.rm = FALSE) {
  v <- ifelse(anyNA(v), na.omit(v), v)
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}
```
```{r}
# fill mean for numeric columns
mean_imp <- train %>%
  mutate_all(~ifelse(is.na(.x),
                     mean(.x, na.rm = TRUE),
                     .x))
# fill mode for categorical columns
mean_imp <- mean_imp %>%
  mutate_all(~ifelse(is.na(.x),
                     getmode(.x, na.rm = TRUE),
                     .x))

# confirm all NA are gone
anyNA(mean_imp)
```

## KNN Imputation

A second method of imputation for numeric variables is the K-Nearest Neighbors estimate. This method is more refined than the previous and incorporates other predictors in its estimate. The default value of k is 10, which we believe is sufficient for our purposes.

For reasons discussed in the next section, we will exclude **Num** from this model.

```{r}
mice_mod <- mice(train[!names(train) %in% c('Transported', 'Num')], method="rf")
knn_imp <- complete(mice_mod)
knn_imp[c('Num', 'Transported')] <- train[c('Num', 'Transported')]
colSums(is.na(knn_imp))
```

The **mice** package allows us to make strong imputation of numeric variables, but there are categorical predictors we have yet to intelligently estimate.

## Group-based Imputation

Upon consideration, we arrived at the assumption that the values of those categorical predictors (**HomePlanet**, **Deck**, **Side**, and **Destination**) is likely similar among members of a group.

Perhaps then, we can consider a group's most common planet of departure, destination, etc. as the best estimate of that group's member.

Below is our implementation of this method. Note that if a group is a single passengers, whose value for a selected variable is NA, that observation cannot be estimated.

```{r}
vars <- c("HomePlanet", "Deck", "Side", "Destination")
# view number of NA in each variable to impute
group_imp <- train
colSums(is.na(group_imp[,vars]))
cat("\n")

# impute HomePlanet by group
na_groups <- unique(group_imp$GroupId[is.na(group_imp$HomePlanet)])
df <- group_imp$GroupId[group_imp$GroupId %in% na_groups]
na_groups <- names(table(df)[table(df) > 1])
for (groupid in na_groups) {
  ls <- c(group_imp$HomePlanet[group_imp$GroupId == groupid])
  mode <- getmode(ls)
  group_imp$HomePlanet <- ifelse(group_imp$GroupId == groupid & is.na(group_imp$HomePlanet), mode, group_imp$HomePlanet)
}

# impute Deck by group
na_groups <- unique(group_imp$GroupId[is.na(group_imp$Deck)])
df <- group_imp$GroupId[group_imp$GroupId %in% na_groups]
na_groups <- names(table(df)[table(df) > 1])
for (groupid in na_groups) {
  ls <- c(group_imp$Deck[group_imp$GroupId == groupid])
  mode <- getmode(ls)
  group_imp$Deck <- ifelse(group_imp$GroupId == groupid & is.na(group_imp$Deck), mode, group_imp$Deck)
}

# impute Side by group
na_groups <- unique(group_imp$GroupId[is.na(group_imp$Side)])
df <- group_imp$GroupId[group_imp$GroupId %in% na_groups]
na_groups <- names(table(df)[table(df) > 1])
for (groupid in na_groups) {
  ls <- c(group_imp$Side[group_imp$GroupId == groupid])
  mode <- getmode(ls)
  group_imp$Side <- ifelse(group_imp$GroupId == groupid & is.na(group_imp$Side), mode, group_imp$Side)
}

# impute Destination by group
na_groups <- unique(group_imp$GroupId[is.na(group_imp$Destination)])
df <- group_imp$GroupId[group_imp$GroupId %in% na_groups]
na_groups <- names(table(df)[table(df) > 1])
for (groupid in na_groups) {
  ls <- c(group_imp$Destination[group_imp$GroupId == groupid])
  mode <- getmode(ls)
  group_imp$Destination <- ifelse(group_imp$GroupId == groupid & is.na(group_imp$Destination), mode, group_imp$Destination)
}
# view number of NA in each variable post-imputation
colSums(is.na(group_imp[,vars]))

```

Is group the strongest predictor of VIP?

## Planet Imputation

Any passenger with missing data for **HomePlanet** and **Destination** is traveling alone. To impute their values, we can identify the most common destination for each home planet (across all passengers), and vice versa. 

```{r}
# view number of NA in each variable to impute
colSums(is.na(group_imp[,vars]))
cat("\n")

# get levels of home and destination planet
homes <- levels(factor(train$HomePlanet))
h_modes <- c()

dests <- levels(factor(train$Destination))
d_modes <- c()

# for each home/destination, compute the mode destination/home
for (i in 1:length(homes)) {
  h_mode <- getmode(c(group_imp$Destination[group_imp$HomePlanet == homes[i]]))
  h_modes <- append(h_modes, h_mode)
  
  d_mode <- getmode(c(group_imp$HomePlanet[group_imp$Destination == dests[i]]))
  d_modes <- append(d_modes, d_mode)
}

home_df <- data.frame("Home" = homes, "ModeDestination"  = h_modes)
dest_df <- data.frame("Destination" = dests, "ModeHomePlanet"  = d_modes)

# fill in value of HomePlanet based on mode Destination
for (dest in dests) {
  group_imp$HomePlanet <- ifelse(
    is.na(group_imp$HomePlanet) & group_imp$Destination == dest, 
    dest_df$ModeHomePlanet[dest_df$Destination == dest],
    group_imp$HomePlanet)
}

# fill in value of Destination based on mode HomePlanet
for (home in homes) {
  group_imp$Destination <- ifelse(
    is.na(group_imp$Destination) & group_imp$HomePlanet == home, 
    home_df$ModeDestination[home_df$Home == home],
    group_imp$Destination)
}

# view number of NA in each variable post-imputation
colSums(is.na(group_imp[,vars]))
```

**End of report.**