---
title: "Imputation with Spaceship Titanic"
author: "Alejandro Hernandez"
date: "2022-08-04"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# set working directory to project directory (outside of SRC folder)
split <- str_split(getwd(), "/", simplify = TRUE)
wdir <- paste(split[-length(split)], collapse = "/")
knitr::opts_knit$set(root.dir = wdir)
```

```{r, include=FALSE}
rm(list=ls())
library(stringr)  # string manipulation
library(dplyr)  # data frame manipulation
library(mice) # imputation functions
library(ggplot2)  # plotting
library(tidyr)  # replacing NA
```

Imputation is the practice of assigning a missing value to an observation/record by inference or prediction. The goal of this script is to impute the necessary fields of the *Spaceship Titanic* dataset. Preferred methods of imputation vary by dataset, so we aim to compare the utility between multiple methods.

First, let's import our dataset, edit some variable types, and count missing values in each field.

```{r}
# get training set
train <- read.csv(sprintf("%s/data/train.csv", getwd()), na.strings = "")

# split aggregate columns
train <- separate(train, col=Cabin, into=c("Deck", "Num", "Side"), sep='/')
train <-  separate(train, col=PassengerId , into=c("GroupId", "PersonalId"), sep='_')
train <-  separate(train, col=Name , into=c("FirstName", "LastName"), sep=' ')

# convert GroupId, PersonalId, and Num to type INTEGER
train[c(1,2,6)] <- sapply(train[c(1,2,6)], as.integer)

# convert missing first and last names to "NONE"
# imputation treats NA, and it wouldn't make sense to impute
train <- train %>%
  mutate_at(c('FirstName','LastName'), ~ replace_na(.,"NONE"))

# encode columns of type LOGICAL to INTEGER (TRUE = 1, FALSE = 0)
train <- train %>%
  mutate_if(is.logical, as.integer)

# confirm each variable is the correct type
sapply(train, typeof)
```

```{r}
# in each column...
# count number of missing values
colSums(is.na(train))
# count proportion of missing values
round(colSums(is.na(train)) / nrow(train), 3)
```

Fields that have missing values are only missing around 200 (barely 2% of their data) so we can continue with imputation without worrying that the majority of the data is being estimated by us.

Now, we can explore methods of imputation.

## Mean/Mode Imputation

Filling missing values of a variable with the variable's mean (if numeric) or mode (if categorical) is a quick, simple, and easy strategy to implement that seems- at a glance- reasonable. However, there are some serious drawbacks to this method. For numeric data, because mean imputed values are totally independent from other predictors, they have the potential to erase correlation between variables.

```{r}
# define function to compute mode
getmode <- function(v, na.rm = FALSE) {
  v <- ifelse(anyNA(v), na.omit(v), v)
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}
```
```{r}
# fill mean for numeric columns
mean_imp <- train %>%
  mutate_all(~ifelse(is.na(.x),
                     mean(.x, na.rm = TRUE),
                     .x))
# fill mode for categorical columns
mean_imp <- mean_imp %>%
  mutate_all(~ifelse(is.na(.x),
                     getmode(.x, na.rm = TRUE),
                     .x))

# confirm all NA are gone
anyNA(mean_imp)
```

## KNN Imputation

A second method of imputation for numeric variables is the K-Nearest Neighbors estimate. This method is more refined than the previous and incorporates other predictors in its estimate. The default value of k is 10, which we believe is sufficient for our purposes.

For reasons discussed in the next section, we will exclude **Num** from this model.

```{r}
mice_mod <- mice(train[!names(train) %in% c('Transported', 'Num')], method="rf")
knn_imp <- complete(mice_mod)
knn_imp[c('Num', 'Transported')] <- train[c( 'Num', 'Transported')]
colSums(is.na(knn_imp))
```

The **mice** package allows us to make strong imputation of numeric variables, but there are categorical predictors we have yet to intelligently estimate.

## Group-based Imputation

Upon consideration, we arrived at the assumption that the values of those categorical predictors (**HomePlanet**, **Deck**, **Side**, and **Destination**) is likely similar among members of a group.

Perhaps then, we can consider a group's most common planet of departure, destination, etc. as the best estimate of that group's member.

Below is our implementation of this method. Note that if a group is a single passengers, whose value for a selected variable is NA, that observation cannot be estimated.

```{r}
# define which categorical variables to impute by group
vars <- c("HomePlanet", "Deck", "Side", "Destination")

group_imp <- train
colSums(is.na(group_imp[,vars]))
cat("\n")

# iterate through each variable
for (var in vars) {
  # get GroupId's that have NA
  na_groups <- unique(group_imp$GroupId[is.na(group_imp[[var]])])
  # get GroupId column that only includes those with NA (repetitions are present)
  df <- group_imp$GroupId[group_imp$GroupId %in% na_groups]
  # we cannot estimate when the only member in the group has NA for the variable
  # get id of NA groups with more than 1 member
  na_groups <- names(table(df)[table(df) > 1])
  
  # for each NA group with more than 1 member, compute group mode and assign to NA
  i <- 0
  for (groupid in na_groups) {
    i <- i + 1
    ls <- c(group_imp[[var]][group_imp$GroupId == groupid])
    mode <- getmode(ls)
    group_imp[[var]][group_imp$GroupId == groupid] <- mode
  }
  cat("Imputed", i, "values of", var, "\n")
}

cat("\n")
colSums(is.na(group_imp[,vars]))
```